<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Game Report</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet" type="text/css">
</head>
<body>
</body>
<script>

var playerData = [];
var eventData = [];
var shiftData = [];
var opponentPairingData = [];
var teammatePairingData = [];
var periodData = [];

var teams = [];

var season = 2014;
var gameId = 30416;
var jsonUrl = "http://127.0.0.1:5000/get-game-data?season=" + season + "&gameId=" + gameId;

d3.json(jsonUrl, function(error, json) {

	periodData = json.filter(function(d) { return d.type === "period"; });
	playerData = json.filter(function(d) { return d.type === "player"; });
	eventData = json.filter(function(d) { return d.type === "event"; });
	shiftData = json.filter(function(d) { return d.type === "shift"; });
	opponentPairingData = json.filter(function(d) { return d.type === "opponents"; });
	teammatePairingData = json.filter(function(d) { return d.type === "teammates"; });

	// Get team names: [away, home]
	teams[0] = json.filter(function(d) { return d.type === "teams"; })[0].away;
	teams[1] = json.filter(function(d) { return d.type === "teams"; })[0].home;

	// Split up pairing keys in the pairing datasets
	teammatePairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});
	opponentPairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});

	// Nest shift data and append player metadata
	shiftData = d3.nest()
		.key(function(d) { return d.playerId; })
		.entries(shiftData);
	shiftData.forEach(function(d) {
		d.key = +d.key;

		var playerProperties = playerData.filter(function(p) { return p.type === "player" && p.playerId === d.key; })[0];
		d.playerId = playerProperties.playerId;
		d.name = playerProperties.name;
		d.number = playerProperties.number;
		d.position = playerProperties.position;
		d.team = playerProperties.team;
		d.toi = playerProperties.toi;
	});

	// Remove all pairings involving goalies
	var goaliePlayerIds = playerData.filter(function(d) { return d.position === "g"; })
		.map(function(d) { return d.playerId; });
	teammatePairingData = teammatePairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.p1) < 0 && goaliePlayerIds.indexOf(d.p2) < 0; });
	opponentPairingData = opponentPairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.playerIds[0]) < 0 && goaliePlayerIds.indexOf(d.playerIds[1]) < 0; });

	// Remove goalie data
	playerData = playerData.filter(function(d) { return d.position !== "g"; });
	shiftData = shiftData.filter(function(d) { return d.position !== "g"; });

	// Group players and set the player display order
	teams.forEach(function(t) {
		groupPlayers(t);
	});

	shiftData = shiftData.sort(function(a, b) {
		var aScore = 0;
		var bScore = 0;

		// The home team is displayed after the away team
		if (a.team === teams[1]) aScore += 1000;
		if (b.team === teams[1]) bScore += 1000;

		// The home team's defensemen are displayed last; the away team's defensemen are displayed first
		if (a.team === teams[1] && a.position === "d") aScore += 500;
		else if (a.team !== teams[1] && a.position !== "d") aScore += 100;
		if (b.team === teams[1] && b.position === "d") bScore += 500;
		else if (b.team !== teams[1] && b.position !== "d") bScore += 100;

		// Adjust the order returned from the groupPlayers function
		// The away team's players are displayed in ascending TOI; descending TOI for the home team
		var adjAOrder = a.order;
		var adjBOrder = b.order;
		if (a.team === b.team && a.team !== teams[1]) {
			adjAOrder = 90 - a.order;
			adjBOrder = 90 - b.order;
		}
		aScore += adjAOrder;
		bScore += adjBOrder;

		return aScore - bScore;
	});

	// Turn shift data into an array: [away shift data, home shift data]
	shiftData = [shiftData.filter(function(d) { return d.team !== teams[0]; }),
		shiftData.filter(function(d) { return d.team !== teams[1]; })];

	initializeVisualization();
});

function initializeVisualization() {

	var secondsPerPixel = 4;
	var rowHeight = 16;
	var dotR = 1.5;
	var hGap = 20;
	var vGap = 16;
	var nameWidth = 120;

	/*
	*
	* Initialize scales
	*
	*/

	var heights = [];
	var yScales = [];

	teams.forEach(function(team, i) {
		heights[i] = shiftData[i].length * rowHeight;

		yScales[i] = d3.scale.ordinal()
			.domain(shiftData[i].map(function(d) { return d.playerId; }))
			.rangePoints([0, heights[i]], 1);
	});

	var xScales = [];
	periodData.forEach(function(period, i) {
		xScales[i] = d3.scale.linear()
			.domain([0, periodData[i].duration])
			.range([0, Math.ceil(periodData[i].duration / secondsPerPixel)]);
	});

	var timelineWidth = Math.ceil(dotR) + d3.sum(xScales, function(d) { return d.range()[1]; }) + hGap * (periodData.length - 1);


	/*
	*
	* Append SVG and groups
	*
	*/

	var svg = d3.select("body").append("svg")
		.attr("id", "shift-chart");

	// Append a group for each team
	var teamGroups = svg.selectAll("g.team")
		.data(teams);
	teamGroups.enter().append("g")
		.attr("class", "team")
		.attr("id", function(d, i) { return "team" + i; });

	// In each team group, append new groups for each period
	var periodGroups = teamGroups.selectAll("g.period")
		.data(periodData);
	periodGroups.enter().append("g")
		.attr("class", "period")
		.attr("id", function(d) { return "period" + d.period; });

	// In each period group, append new groups that are bound to events that occurred in the period
	var eventGroups = periodGroups.selectAll("g.event")
		.data(function(period) {
			return eventData.filter(function(ev) { return ev.period === period.period; });
		});
	eventGroups.enter().append("g")
		.attr("class", "event")
		.attr("id", function(d) { return "event" + d["id"]; });

	// For each team and period, append groups for players on the team
	teams.forEach(function(team, i) {
		var playerGroups = d3.select("#team" + i).selectAll("g.period").selectAll("g.player")
			.data(shiftData[i]);
		playerGroups.enter().append("g")
			.attr("class", "player")
			.attr("id", function(d) {
				// Replace all spaces and periods in the player name
				return d.name.replace(/\ /g, "").replace(/\./g, "") + d.playerId;
			});
	});

	// Append shift lines to each player group - only for shifts in the period
	periodData.forEach(function(period) {
		var shiftLines = d3.selectAll("g.team").selectAll("#period" + period.period).selectAll("g.player").selectAll("line.shift")
			.data(function(d) {
				return d.values.filter(function(s) { return s.period === period.period; });
			});
		shiftLines.enter().append("line")
			.attr("class", "shift")
			.attr("id", function(d) { return d.playerId + "&" + d.period + "&" + d.start + "-" + d.end; });
	});

	// g.team0 (bound to shiftData)
		// g.period1 (not bound to anything - just create manually)
			//g.event (create a group for each event in period)
				// line.def
				// line.fwd
				// dot.player (create a dot for each event player)
			//g.player (create a group for each shiftData player)
				// line.shift (create a line for each shift belonging to the player)
		// g.period2
		// g.period3
		// g.intermission1 (not bound to anything - just create manually)
			// text.numbers
		// g.intermission2
		// g.names (not bound to anything - just create manually)
			// text.name (access the playernames in the bound shiftData)
	// g.team1 (bound to shiftData)
		// g.period1
		// g.period2
		// g.period3
		// g.intermission1
		// g.intermission2
		// g.names
}

function groupPlayers(team) {

	/*
	*
	* Prepare data needed to group players
	*
	*/

	// Get pairing data for specified team
	// Append individual TOIs, and shift similarity to data
	var pairingData = teammatePairingData.filter(function(d) { return d.team === team; });
	pairingData.forEach(function(pair) {
		pair.p1Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p1; })[0].ev5Toi;
		pair.p2Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p2; })[0].ev5Toi;
		pair.shiftSimilarity = pair.toi / (pair.p1Toi + pair.p2Toi - pair.toi);
	});

	/*
	*
	* Group players by shift similarity
	*
	*/

	var playerSets = [];
	var ungroupedPlayers = playerData.filter(function(d) { return d.team === team; })
		.map(function(d) { return d.playerId; });

	// Sort pairings by descending similarity, then start grouping players with the highest shift similarities
	var minSimilarity = 0.5;
	pairingData = pairingData.sort(function(a, b) { return b.shiftSimilarity - a.shiftSimilarity; });
	pairingData.forEach(function(pair) {
		if (pair.shiftSimilarity >= minSimilarity) {

			var grouped = false;

			// If 1 or more player sets exist, then check to see if the current pair should be added to an existing set
			var i = 0;
			while (!grouped && i < playerSets.length) {
				if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) < 0) {
					// If an existing set contains p1 but not p2, add p2 to the existing set
					playerSets[i].push(pair.p2);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) < 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set contains p2 but not p1, add p1 to the existing set
					playerSets[i].push(pair.p1);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set already contains both p1 and p2, then no updates needed
					grouped = true;
				}
				i++;
			}

			// If the existing pair doesn't belong to any existing player set, then create a new set
			if (!grouped) {
				playerSets.push([pair.p1, pair.p2]);
			}

			// Remove the grouped players from the list of ungrouped players
			[pair.p1, pair.p2].forEach(function(p) {
				var deleteIndex = ungroupedPlayers.indexOf(p);
				if (deleteIndex >= 0) {
					ungroupedPlayers.splice(deleteIndex, 1);
				}
			});
		}
	});

	// For testing: Print player sets with names
	// playerSets.forEach(function(set) {
	// 	var names = [];
	// 	set.forEach(function(p) {
	// 		playerName = playerData.filter(function(d) { return d.team === team && d.playerId === p; })[0].name;
	// 		names.push(playerName);
	// 	});
	// 	console.log(names);
	// });

	/*
	*
	* Sort all the sets and ungrouped players by descending TOI
	*
	*/

	var sortedPlayers = [];

	// Add the player sets to the list to be sorted
	// Sets will be sorted based on their average TOI
	playerSets.forEach(function(set) {

		// Get the shift data for each player in the set
		// Sort the players by descending TOI
		var setPlayers = shiftData.filter(function(p) { return set.indexOf(p.playerId) >= 0; });
		setPlayers.sort(function(a, b) { return b.toi - a.toi; });

		sortedPlayers.push({
			players: set,
			toi: d3.mean(setPlayers, function(p) { return p.toi; })
		});
	});

	// Add the ungrouped players to the list to be sorted
	ungroupedPlayers.forEach(function(player) {
		var playerData = shiftData.filter(function(p) { return p.playerId === player; });
		sortedPlayers.push({
			players: [player],
			toi: playerData[0].toi
		});
	});

	// Sort the combined list of sets and ungrouped players by descending TOI
	sortedPlayers.sort(function(a, b) { return b.toi - a.toi; });

	// Convert the sorted players into a flat list
	sortedPlayers = sortedPlayers.map(function(d) { return d.players; });
	sortedPlayers = [].concat.apply([], sortedPlayers);

	// Record the sort order in the shiftData
	shiftData.filter(function(p) { return p.team === team; })
		.forEach(function(p) {
			p.order = sortedPlayers.indexOf(p.playerId);
		});
}

</script>
</body>
</html>


