<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Game Report</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet" type="text/css">
</head>
<body>
</body>
<script>

var playerData = [];
var eventData = [];
var shiftData = [];
var opponentPairingData = [];
var teammatePairingData = [];
var powerplayData = [];
var periodData = [];

var teams = [];
var blueTeam = "";

var season = 2014;
var gameId = 30324;
//var gameId = 30416;
var jsonUrl = "http://127.0.0.1:5000/get-game-data?season=" + season + "&gameId=" + gameId;

d3.json(jsonUrl, function(error, json) {

	periodData = json.filter(function(d) { return d.type === "period"; });
	playerData = json.filter(function(d) { return d.type === "player"; });
	eventData = json.filter(function(d) { return d.type === "event"; });
	shiftData = json.filter(function(d) { return d.type === "shift"; });
	opponentPairingData = json.filter(function(d) { return d.type === "opponents"; });
	teammatePairingData = json.filter(function(d) { return d.type === "teammates"; });
	powerplayData = json.filter(function(d) { return d.type === "powerplay"; });
	console.log(powerplayData);

	// Get team names: [away, home]
	teams[0] = json.filter(function(d) { return d.type === "teams"; })[0].away;
	teams[1] = json.filter(function(d) { return d.type === "teams"; })[0].home;
	blueTeam = teams[0];

	// Split up pairing keys in the pairing datasets
	teammatePairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});
	opponentPairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});

	// Nest shift data and append player metadata
	shiftData = d3.nest()
		.key(function(d) { return d.playerId; })
		.entries(shiftData);
	shiftData.forEach(function(d) {
		d.key = +d.key;

		var playerProperties = playerData.filter(function(p) { return p.type === "player" && p.playerId === d.key; })[0];
		d.playerId = playerProperties.playerId;
		d.name = playerProperties.name;
		d.number = playerProperties.number;
		d.position = playerProperties.position;
		d.team = playerProperties.team;
		d.toi = playerProperties.toi;
	});

	// Record separate lists for forwards and defense on ice for each event - this will be used to draw the event lines
	eventData.forEach(function(d) {
		var skatersOnIce = [d.awaySkaters, d.homeSkaters];
		var defensemen = [[], []];
		var forwards = [[], []];

		skatersOnIce.forEach(function(teamSkaters, i) {
			teamSkaters.filter(function(d) { return d > 0; }).forEach(function(s) {
				var thisPlayerData = playerData.filter(function(d) { return d.playerId === s; })[0];
				if (["l", "r", "c"].indexOf(thisPlayerData.position) >= 0) {
					defensemen[i].push(s);
				}else if (thisPlayerData.position === "d") {
					forwards[i].push(s);
				}
			});
		});

		d.awayDefensemen = defensemen[0];
		d.homeDefensemen = defensemen[1];
		d.awayForwards = forwards[0];
		d.homeForwards = forwards[1];
	});

	// Remove all pairings involving goalies
	var goaliePlayerIds = playerData.filter(function(d) { return d.position === "g"; })
		.map(function(d) { return d.playerId; });
	teammatePairingData = teammatePairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.p1) < 0 && goaliePlayerIds.indexOf(d.p2) < 0; });
	opponentPairingData = opponentPairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.playerIds[0]) < 0 && goaliePlayerIds.indexOf(d.playerIds[1]) < 0; });

	// Remove goalie data
	playerData = playerData.filter(function(d) { return d.position !== "g"; });
	shiftData = shiftData.filter(function(d) { return d.position !== "g"; });

	// Group players and set the player display order
	teams.forEach(function(t) {
		groupPlayers(t);
	});

	shiftData = shiftData.sort(function(a, b) {
		var aScore = 0;
		var bScore = 0;

		// The home team is displayed after the away team
		if (a.team === teams[1]) aScore += 1000;
		if (b.team === teams[1]) bScore += 1000;

		// The home team's defensemen are displayed last; the away team's defensemen are displayed first
		if (a.team === teams[1] && a.position === "d") aScore += 500;
		else if (a.team !== teams[1] && a.position !== "d") aScore += 100;
		if (b.team === teams[1] && b.position === "d") bScore += 500;
		else if (b.team !== teams[1] && b.position !== "d") bScore += 100;

		// Adjust the order returned from the groupPlayers function
		// The away team's players are displayed in ascending TOI; descending TOI for the home team
		var adjAOrder = a.order;
		var adjBOrder = b.order;
		if (a.team === b.team && a.team !== teams[1]) {
			adjAOrder = 90 - a.order;
			adjBOrder = 90 - b.order;
		}
		aScore += adjAOrder;
		bScore += adjBOrder;

		return aScore - bScore;
	});

	// Turn shift data into an array: [away shift data, home shift data]
	shiftData = [shiftData.filter(function(d) { return d.team === teams[0]; }),
		shiftData.filter(function(d) { return d.team === teams[1]; })];

	initializeVisualization();
});

function initializeVisualization() {

	var secondsPerPixel = 4;
	var rowHeight = 16;
	var dotR = 1.5;
	var intermissionGap = 40;
	var gameEndGap = 20;
	var vGap = 24;
	var nameWidth = 120;

	var red = "#ee0000";
	var blue = "#0000ee";

	/*
	*
	* Initialize scales
	*
	*/

	var yScales = [];

	teams.forEach(function(team, i) {
		yScales[i] = d3.scale.ordinal()
			.domain(shiftData[i].map(function(d) { return d.playerId; }))
			.rangePoints([0, shiftData[i].length * rowHeight], 1);
	});

	var xScales = [];
	periodData.forEach(function(period, i) {
		xScales[i] = d3.scale.linear()
			.domain([0, periodData[i].duration])
			.range([0, Math.ceil(periodData[i].duration / secondsPerPixel)]);
	});

	var timelineWidth = Math.ceil(dotR) + d3.sum(xScales, function(d) { return d.range()[1]; }) + intermissionGap * (periodData.length - 1);

	/*
	*
	* Append SVG and groups
	*
	*/

	var svg = d3.select("body").append("svg")
		.attr("id", "shift-chart")
		.style("background", "none")
		.style("font-family", "Roboto")
		.style("font-size", "12px")
		.style("height", (shiftData[0].length + shiftData[1].length) * rowHeight + vGap)
		.style("width", timelineWidth + gameEndGap + nameWidth + "px");

	// Append a group for each team
	var teamGroups = svg.selectAll("g.team")
		.data(teams);
	teamGroups.enter().append("g")
		.attr("class", "team")
		.attr("id", function(d, i) { return "team" + i; })
		.attr("transform", function(d, i) {
			if (i === 1) {
				return "translate(0," + (shiftData[0].length * rowHeight + vGap) + ")";
			} else {
				return "translate(0,0)";
			}
		});

	var ppGroup = svg.append("g")
		.attr("class", "powerplay")
		.attr("transform", function(d, i) { return "translate(0," + (shiftData[0].length * rowHeight) + ")"; });

	// Append group for player names
	var nameGroups = teamGroups.append("g")
		.attr("class", "names")
		.attr("transform", "translate(" + (timelineWidth + gameEndGap) + ",0)");

	// In each team group and the powerplay group, append new groups for each period and intermission
	var periodGroups = svg.selectAll("g.team, g.powerplay").selectAll("g.period")
		.data(periodData);
	periodGroups.enter().append("g")
		.attr("class", function(d) { return "period period" + d.period; })
		.attr("transform", function(d) {
			var xShift = 0;
			for (var j = 1; j < d.period; j++) {
				xShift += xScales[j - 1].range()[1];
			}
			xShift += (d.period - 1) * intermissionGap;
			return "translate(" + xShift + ",0)";
		});

	var intermissionGroups = teamGroups.selectAll("g.intermission")
		.data(function() {
			var intermissions = [];
			for (var i = 1; i < periodData.length; i++) {
				intermissions.push(i);
			}
			return intermissions;
		});
	intermissionGroups.enter().append("g")
		.attr("class", function(d) { return "intermission intermission" + d; })
		.attr("transform", function(d) {
			var xShift = 0;
			for (var j = 1; j <= d; j++) {
				xShift += xScales[j - 1].range()[1];
			}
			xShift += (d - 1) * intermissionGap;
			return "translate(" + xShift + ",0)";
		});


	// For each team and period, append groups for players on the team
	teams.forEach(function(team, i) {
		var playerGroups = d3.select("#team" + i).selectAll("g.period").selectAll("g.player")
			.data(shiftData[i]);
		playerGroups.enter().append("g")
			.attr("class", "player");
	});

	/*
	*
	* Append elements to groups
	*
	*/

	// Append player names for each team
	teams.forEach(function(team, i) {
		var names = d3.select("#team" + i).select("g.names").selectAll("text.name")
			.data(shiftData[i]);
		names.enter().append("text")
			.attr("class", "name")
			.attr("x", 0)
			.attr("y", function(d) { return yScales[i](d.playerId); })
			.style("alignment-baseline", "middle")
			.style("fill", function(d) {
				if (d.team === blueTeam) {
					return blue;
				} else {
					return red;
				}
			})
			.style("fill-opacity", 0.6)
			.text(function(d) { return d.name; });

		var numbers = d3.select("#team" + i).selectAll("g.intermission").selectAll("text.number")
			.data(shiftData[i]);
		numbers.enter().append("text")
			.attr("class", "number")
			.attr("x", intermissionGap / 2)
			.attr("y", function(d) { return yScales[i](d.playerId); })
			.style("alignment-baseline", "middle")
			.style("text-anchor", "middle")
			.style("fill", function(d) {
				if (d.team === blueTeam) {
					return blue;
				} else {
					return red;
				}
			})
			.style("fill-opacity", 0.6)
			.style("font-size", 10)
			.text(function(d) { return d.number; });
	});

	// Append shift lines to each player group - only for shifts in the period
	periodData.forEach(function(period) {
		var shiftLines = d3.selectAll("g.team").selectAll(".period.period" + period.period).selectAll("g.player").selectAll("line.shift")
			.data(function(d) {
				return d.values.filter(function(s) { return s.period === period.period; });
			});
		shiftLines.enter().append("line")
			.attr("class", "shift")
			.attr("x1", function(d) { return xScales[period.period - 1](d.start); })
			.attr("x2", function(d) { return xScales[period.period - 1](d.end); })
			.attr("y1", function(d) { return yScales[teams.indexOf(d.team)](d.playerId); })
			.attr("y2", function(d) { return yScales[teams.indexOf(d.team)](d.playerId); })
			.style("stroke", "#f7f7f7")
			.style("stroke-width", 15);
	});

	// In each period group, append new groups that are bound to events that occurred in the period
	// Identify which events are goals using the "goal" class
	var eventGroups = d3.selectAll("g.team").selectAll(".period").selectAll("g.event")
		.data(function(period) {
			return eventData.filter(function(ev) { return ev.period === period.period; });
		});
	eventGroups.enter().append("g")
		.attr("class", function(d) {
			var groupClass = "event";
			if (d.eventType === "goal") {
				groupClass += " goal";
			}
			return groupClass;
		});

	teams.forEach(function(team, i) {

		// Append event lines
		["fwd", "def"].forEach(function(pos) {

			var propertyName;
			if (i === 0) {
				propertyName = "away";
			} else if (i === 1) {
				propertyName = "home";
			}
			if (pos === "fwd") {
				propertyName += "Forwards";
			} else if (pos === "def") {
				propertyName += "Defensemen";
			}

			d3.select("#team" + i).selectAll("g.event").append("line")
				.attr("class", pos)
				.attr("x1", function(d) { return xScales[d.period - 1](d.time); })
				.attr("x2", function(d) { return xScales[d.period - 1](d.time); })
				.attr("y1", function(d) { return d3.min(d[propertyName], function(s) { return yScales[i](s); }); })
				.attr("y2", function(d) { return d3.max(d[propertyName], function(s) { return yScales[i](s); }); })
				.style("stroke", function(d) {
					if (d.eventTeam === blueTeam) {
						return blue;
					} else {
						return red;
					}
				})
				.style("stroke-opacity", 0.15);
		});

		// Append event dots
		var propertyName;
		if (i === 0) {
			propertyName = "awaySkaters";
		} else if (i === 1) {
			propertyName = "homeSkaters";
		}

		var eventGroups = d3.select("#team" + i).selectAll("g.event");
		eventGroups[0].forEach(function(g) {
			g.__data__[propertyName].filter(function(s) { return s > 0; }).forEach(function(s) {
				d3.select(g).append("circle")
					.attr("cx", function(d) { return xScales[d.period - 1](d.time); })
					.attr("cy", function() { return yScales[i](s); })
					.style("r", dotR)
					.style("fill", function(d) {
						if (d.eventTeam === blueTeam) {
							return blue;
						} else {
							return red;
						}
					});
			});
		});

		// Append goal circles
		var eventGroups = d3.select("#team" + i).selectAll("g.goal");
		eventGroups[0].forEach(function(g) {
			g.__data__[propertyName].filter(function(s) { return s > 0; }).forEach(function(s) {
				d3.select(g).append("circle")
					.attr("cx", function(d) { return xScales[d.period - 1](d.time); })
					.attr("cy", function() { return yScales[i](s); })
					.style("r", function(d) {
						if (d.eventP1 === s) {
							return dotR * 3 - 0.5;
						} else {
							return dotR * 3;
						}
					})
					.style("fill-opacity", 0.2)
					.style("fill", function(d) {
						if (d.eventP1 !== 1) {
							if (d.eventTeam === blueTeam) {
								return blue;
							} else {
								return red;
							}
						} else {
							return "none";
						}
					})
					.style("stroke-opacity", 0.6)
					.style("stroke", function(d) {
						if (d.eventP1 === s) {
							if (d.eventTeam === blueTeam) {
								return blue;
							} else {
								return red;
							}
						} else {
							return "none";
						}
					});
			});
		});
	});

	/*
	*
	* Append powerplay markers
	*
	*/

	periodData.forEach(function(per) {
		var ppLines = d3.select("g.powerplay").select(".period.period" + per.period).selectAll("line")
			.data(powerplayData.filter(function(d) { return d.period === per.period; }));
		ppLines.enter().append("line")
			.attr("x1", function(d) { return xScales[d.period - 1](d.start); })
			.attr("x2", function(d) { return xScales[d.period - 1](d.end); })
			.attr("y1", vGap / 2)
			.attr("y2", vGap / 2)
			.attr("stroke-width", 15)
			.attr("stroke-opacity", 0.15)
			.attr("stroke", function(d) {
				if (d.team === blueTeam) {
					return blue;
				} else {
					return red;
				}
			});

		var goalMarkers = d3.select("g.powerplay").select(".period.period" + per.period).selectAll(".goal")
			.data(eventData.filter(function(ev) { return ev.period === per.period && ev.eventType === "goal"; }));
		goalMarkers.enter().append("text")
			.attr("class", "goal")
			.attr("x", function(d) { return xScales[d.period - 1](d.time); })
			.attr("y", vGap / 2)
			.style("alignment-baseline", "middle")
			.style("text-anchor", "middle")
			.style("font-size", "10px")
			.style("fill", function(d){
				if (d.eventTeam === blueTeam) {
					return blue;
				} else {
					return red;
				}
			})
			.text(function(d) {
				var goals = eventData.filter(function(ev) {
					return ev.eventType === "goal" && ev.eventTeam === d.eventTeam
						&& (ev.period < d.period || (ev.period === d.period && ev.time <= d.time));
				});
				return goals.length;
			});
	});
}

function groupPlayers(team) {

	/*
	*
	* Prepare data needed to group players
	*
	*/

	// Get pairing data for specified team
	// Append individual TOIs, and shift similarity to data
	var pairingData = teammatePairingData.filter(function(d) { return d.team === team; });
	pairingData.forEach(function(pair) {
		pair.p1Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p1; })[0].ev5Toi;
		pair.p2Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p2; })[0].ev5Toi;
		pair.shiftSimilarity = pair.toi / (pair.p1Toi + pair.p2Toi - pair.toi);
	});

	/*
	*
	* Group players by shift similarity
	*
	*/

	var playerSets = [];
	var ungroupedPlayers = playerData.filter(function(d) { return d.team === team; })
		.map(function(d) { return d.playerId; });

	// Sort pairings by descending similarity, then start grouping players with the highest shift similarities
	var minSimilarity = 0.5;
	pairingData = pairingData.sort(function(a, b) { return b.shiftSimilarity - a.shiftSimilarity; });
	pairingData.forEach(function(pair) {
		if (pair.shiftSimilarity >= minSimilarity) {

			var grouped = false;

			// If 1 or more player sets exist, then check to see if the current pair should be added to an existing set
			var i = 0;
			while (!grouped && i < playerSets.length) {
				if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) < 0) {
					// If an existing set contains p1 but not p2, add p2 to the existing set
					playerSets[i].push(pair.p2);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) < 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set contains p2 but not p1, add p1 to the existing set
					playerSets[i].push(pair.p1);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set already contains both p1 and p2, then no updates needed
					grouped = true;
				}
				i++;
			}

			// If the existing pair doesn't belong to any existing player set, then create a new set
			if (!grouped) {
				playerSets.push([pair.p1, pair.p2]);
			}

			// Remove the grouped players from the list of ungrouped players
			[pair.p1, pair.p2].forEach(function(p) {
				var deleteIndex = ungroupedPlayers.indexOf(p);
				if (deleteIndex >= 0) {
					ungroupedPlayers.splice(deleteIndex, 1);
				}
			});
		}
	});

	// For testing: Print player sets with names
	// playerSets.forEach(function(set) {
	// 	var names = [];
	// 	set.forEach(function(p) {
	// 		playerName = playerData.filter(function(d) { return d.team === team && d.playerId === p; })[0].name;
	// 		names.push(playerName);
	// 	});
	// 	console.log(names);
	// });

	/*
	*
	* Sort all the sets and ungrouped players by descending TOI
	*
	*/

	var sortedPlayers = [];

	// Add the player sets to the list to be sorted
	// Sets will be sorted based on their average TOI
	playerSets.forEach(function(set) {

		// Get the shift data for each player in the set
		// Sort the players by descending TOI
		var setPlayers = shiftData.filter(function(p) { return set.indexOf(p.playerId) >= 0; });
		setPlayers.sort(function(a, b) { return b.toi - a.toi; });

		sortedPlayers.push({
			players: set,
			toi: d3.mean(setPlayers, function(p) { return p.toi; })
		});
	});

	// Add the ungrouped players to the list to be sorted
	ungroupedPlayers.forEach(function(player) {
		var playerData = shiftData.filter(function(p) { return p.playerId === player; });
		sortedPlayers.push({
			players: [player],
			toi: playerData[0].toi
		});
	});

	// Sort the combined list of sets and ungrouped players by descending TOI
	sortedPlayers.sort(function(a, b) { return b.toi - a.toi; });

	// Convert the sorted players into a flat list
	sortedPlayers = sortedPlayers.map(function(d) { return d.players; });
	sortedPlayers = [].concat.apply([], sortedPlayers);

	// Record the sort order in the shiftData
	shiftData.filter(function(p) { return p.team === team; })
		.forEach(function(p) {
			p.order = sortedPlayers.indexOf(p.playerId);
		});
}

</script>
</body>
</html>


