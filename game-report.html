<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Game Report</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet" type="text/css">
</head>
<body>
</body>
<script>

var playerData = [];
var eventData = [];
var shiftData = [];
var opponentPairingData = [];
var teammatePairingData = [];
var periodData = [];

var teams = [];
var blueTeam = "";

var season = 2014;
var gameId = 30416;
var jsonUrl = "http://127.0.0.1:5000/get-game-data?season=" + season + "&gameId=" + gameId;

d3.json(jsonUrl, function(error, json) {

	periodData = json.filter(function(d) { return d.type === "period"; });
	playerData = json.filter(function(d) { return d.type === "player"; });
	eventData = json.filter(function(d) { return d.type === "event"; });
	shiftData = json.filter(function(d) { return d.type === "shift"; });
	opponentPairingData = json.filter(function(d) { return d.type === "opponents"; });
	teammatePairingData = json.filter(function(d) { return d.type === "teammates"; });

	// Get team names: [away, home]
	teams[0] = json.filter(function(d) { return d.type === "teams"; })[0].away;
	teams[1] = json.filter(function(d) { return d.type === "teams"; })[0].home;
	blueTeam = teams[0];

	// Split up pairing keys in the pairing datasets
	teammatePairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});
	opponentPairingData.forEach(function(pair) {
		pair.p1 = +pair.playerIds.substring(0, pair.playerIds.indexOf("&"));
		pair.p2 = +pair.playerIds.substring(pair.playerIds.indexOf("&") + 1);
	});

	// Nest shift data and append player metadata
	shiftData = d3.nest()
		.key(function(d) { return d.playerId; })
		.entries(shiftData);
	shiftData.forEach(function(d) {
		d.key = +d.key;

		var playerProperties = playerData.filter(function(p) { return p.type === "player" && p.playerId === d.key; })[0];
		d.playerId = playerProperties.playerId;
		d.name = playerProperties.name;
		d.number = playerProperties.number;
		d.position = playerProperties.position;
		d.team = playerProperties.team;
		d.toi = playerProperties.toi;
	});

	// Remove all pairings involving goalies
	var goaliePlayerIds = playerData.filter(function(d) { return d.position === "g"; })
		.map(function(d) { return d.playerId; });
	teammatePairingData = teammatePairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.p1) < 0 && goaliePlayerIds.indexOf(d.p2) < 0; });
	opponentPairingData = opponentPairingData.filter(function(d) { return goaliePlayerIds.indexOf(d.playerIds[0]) < 0 && goaliePlayerIds.indexOf(d.playerIds[1]) < 0; });

	// Remove goalie data
	playerData = playerData.filter(function(d) { return d.position !== "g"; });
	shiftData = shiftData.filter(function(d) { return d.position !== "g"; });

	// Group players and set the player display order
	teams.forEach(function(t) {
		groupPlayers(t);
	});

	shiftData = shiftData.sort(function(a, b) {
		var aScore = 0;
		var bScore = 0;

		// The home team is displayed after the away team
		if (a.team === teams[1]) aScore += 1000;
		if (b.team === teams[1]) bScore += 1000;

		// The home team's defensemen are displayed last; the away team's defensemen are displayed first
		if (a.team === teams[1] && a.position === "d") aScore += 500;
		else if (a.team !== teams[1] && a.position !== "d") aScore += 100;
		if (b.team === teams[1] && b.position === "d") bScore += 500;
		else if (b.team !== teams[1] && b.position !== "d") bScore += 100;

		// Adjust the order returned from the groupPlayers function
		// The away team's players are displayed in ascending TOI; descending TOI for the home team
		var adjAOrder = a.order;
		var adjBOrder = b.order;
		if (a.team === b.team && a.team !== teams[1]) {
			adjAOrder = 90 - a.order;
			adjBOrder = 90 - b.order;
		}
		aScore += adjAOrder;
		bScore += adjBOrder;

		return aScore - bScore;
	});

	// Turn shift data into an array: [away shift data, home shift data]
	shiftData = [shiftData.filter(function(d) { return d.team === teams[0]; }),
		shiftData.filter(function(d) { return d.team === teams[1]; })];

	initializeVisualization();
});

function initializeVisualization() {

	var secondsPerPixel = 4;
	var rowHeight = 16;
	var dotR = 1.5;
	var hGap = 20;
	var vGap = 16;
	var nameWidth = 120;

	var red = "#ee0000";
	var blue = "#0000ee";

	/*
	*
	* Initialize scales
	*
	*/

	var yScales = [];

	teams.forEach(function(team, i) {
		yScales[i] = d3.scale.ordinal()
			.domain(shiftData[i].map(function(d) { return d.playerId; }))
			.rangePoints([0, shiftData[i].length * rowHeight], 1);
	});

	var xScales = [];
	periodData.forEach(function(period, i) {
		xScales[i] = d3.scale.linear()
			.domain([0, periodData[i].duration])
			.range([0, Math.ceil(periodData[i].duration / secondsPerPixel)]);
	});

	var timelineWidth = Math.ceil(dotR) + d3.sum(xScales, function(d) { return d.range()[1]; }) + hGap * (periodData.length - 1);

	/*
	*
	* Append SVG and groups
	*
	*/

	var svg = d3.select("body").append("svg")
		.attr("id", "shift-chart")
		.style("background", "none")
		.style("font-family", "Roboto")
		.style("font-size", "13px")
		.style("height", (shiftData[0].length + shiftData[1].length) * rowHeight + vGap)
		.style("width", timelineWidth + hGap + nameWidth + "px");

	// Append a group for each team
	var teamGroups = svg.selectAll("g.team")
		.data(teams);
	teamGroups.enter().append("g")
		.attr("class", "team")
		.attr("id", function(d, i) { return "team" + i; })
		.attr("transform", function(d, i) { return "translate(0," + i * (shiftData[0].length * rowHeight + vGap) + ")"; });

	// Append group for player names
	var nameGroups = teamGroups.append("g")
		.attr("class", "names")
		.attr("transform", "translate(" + (timelineWidth + hGap) + ",0)");

	// In each team group, append new groups for each period
	var periodGroups = teamGroups.selectAll("g.period")
		.data(periodData);
	periodGroups.enter().append("g")
		.attr("class", function(d) { return "period period" + d.period; })
		.attr("transform", function(d) {
			var xShift = 0;
			for (var j = 1; j < d.period; j++) {
				xShift += xScales[j].range()[1];
			}
			xShift += (d.period - 1) * hGap;
			return "translate(" + xShift + ",0)";
		});

	// For each team and period, append groups for players on the team
	teams.forEach(function(team, i) {
		var playerGroups = d3.select("#team" + i).selectAll("g.period").selectAll("g.player")
			.data(shiftData[i]);
		playerGroups.enter().append("g")
			.attr("class", "player");
	});

	/*
	*
	* Append elements to groups
	*
	*/

	// Append player names for each team
	teams.forEach(function(team, i) {
		var names = d3.select("#team" + i).select("g.names").selectAll("text.name")
			.data(shiftData[i]);
		names.enter().append("text")
			.attr("class", "name")
			.attr("x", 0)
			.attr("y", function(d) { return yScales[i](d.playerId); })
			.style("alignment-baseline", "middle")
			.style("fill", function(d) {
				if (d.team === blueTeam) {
					return blue;
				} else {
					return red;
				}
			})
			.style("fill-opacity", 0.6)
			.text(function(d) { return d.name; });

		var numberGroup = d3.select("#team" + i).append("g")
			.attr("class", "numbers");
		var numbers = d3.select("#team" + i).select("g.numbers").selectAll("text.number")
			.data(shiftData[i]);
		numbers.enter().append("text")
			.attr("class", "number")
			.attr("x", xScales[0].range()[1] + hGap / 2)
			.attr("y", function(d) { return yScales[i](d.playerId); })
			.style("alignment-baseline", "middle")
			.style("text-anchor", "middle")
			.style("fill", function(d) {
				if (d.team === blueTeam) {
					return blue;
				} else {
					return red;
				}
			})
			.style("fill-opacity", 0.6)
			.style("font-size", 10)
			.text(function(d) { return d.number; });
	});

	// Append shift lines to each player group - only for shifts in the period
	periodData.forEach(function(period) {
		var shiftLines = d3.selectAll("g.team").selectAll(".period.period" + period.period).selectAll("g.player").selectAll("line.shift")
			.data(function(d) {
				return d.values.filter(function(s) { return s.period === period.period; });
			});
		shiftLines.enter().append("line")
			.attr("class", "shift")
			.attr("x1", function(d) { return xScales[period.period - 1](d.start); })
			.attr("x2", function(d) { return xScales[period.period - 1](d.end); })
			.attr("y1", function(d) { return yScales[teams.indexOf(d.team)](d.playerId); })
			.attr("y2", function(d) { return yScales[teams.indexOf(d.team)](d.playerId); })
			.style("stroke", "#f7f7f7")
			.style("stroke-width", 15);
	});

	// In each period group, append new groups that are bound to events that occurred in the period
	var eventGroups = periodGroups.selectAll("g.event")
		.data(function(period) {
			return eventData.filter(function(ev) { return ev.period === period.period; });
		});
	eventGroups.enter().append("g")
		.attr("class", "event");

	// Append event lines and dots
	teams.forEach(function(team, i) {

		// Event lines
		["fwd", "def"].forEach(function(pos) {
			var lines = d3.select("#team" + i).selectAll("g.event").selectAll("line." + pos)
				.data(function(d) {
					var skatersOnIce = [];
					var returnedSkaters = [];
					if (i === 0) {
						skatersOnIce = d.awaySkaters.filter(function(s) { return s > 0; });
					} else if (i === 1) {
						skatersOnIce = d.homeSkaters.filter(function(s) { return s > 0; });
					}
					skatersOnIce.forEach(function(s) {
						var thisPlayerData = playerData.filter(function(d) { return d.playerId === s; })[0];
						if (pos === "fwd" && ["l", "r", "c"].indexOf(thisPlayerData.position) >= 0) {
							returnedSkaters.push(s);
						} else if (pos === "def" && thisPlayerData.position === "d") {
							returnedSkaters.push(s);
						}
					});
					// Return the skaters as [[s1, s2, s3]] to draw one line per set
					return [returnedSkaters];
				});
			lines.enter().append("line")
				.attr("class", pos)
				.attr("x1", function() {
					// Get the data that's bound to the parent event group
					var thisEventData = d3.select(this.parentNode).data()[0];
					return xScales[thisEventData.period - 1](thisEventData.time);
				})
				.attr("x2", function() {
					var thisEventData = d3.select(this.parentNode).data()[0];
					return xScales[thisEventData.period - 1](thisEventData.time);
				})
				.attr("y1", function(d) { return d3.min(d, function(s) { return yScales[i](s); }); })
				.attr("y2", function(d) { return d3.max(d, function(s) { return yScales[i](s); }); })
				.style("stroke", function(d) {
					var thisEventData = d3.select(this.parentNode).data()[0];
					if (thisEventData.eventTeam === blueTeam) {
						return blue;
					} else {
						return red;
					}
				})
				.style("stroke-opacity", 0.15)
		});

		// Event dots
		var dots = d3.select("#team" + i).selectAll("g.event").selectAll("circle")
			.data(function(d) {
				if (i === 0) {
					return d.awaySkaters.filter(function(s) { return s > 0; });
				} else if (i === 1) {
					return d.homeSkaters.filter(function(s) { return s > 0; });
				}
			});
		dots.enter().append("circle")
			.attr("cx", function() {
				var thisEventData = d3.select(this.parentNode).data()[0];
				return xScales[thisEventData.period - 1](thisEventData.time);
			})
			.attr("cy", function(d) { return yScales[i](d); })
			.style("r", dotR)
			.style("fill", function(d) {
				var thisEventData = d3.select(this.parentNode).data()[0];
				if (thisEventData.eventTeam === blueTeam) {
					return blue;
				} else {
					return red;
				}
			});
	});

}

function groupPlayers(team) {

	/*
	*
	* Prepare data needed to group players
	*
	*/

	// Get pairing data for specified team
	// Append individual TOIs, and shift similarity to data
	var pairingData = teammatePairingData.filter(function(d) { return d.team === team; });
	pairingData.forEach(function(pair) {
		pair.p1Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p1; })[0].ev5Toi;
		pair.p2Toi = playerData.filter(function(d) { return d.team === team && d.playerId === pair.p2; })[0].ev5Toi;
		pair.shiftSimilarity = pair.toi / (pair.p1Toi + pair.p2Toi - pair.toi);
	});

	/*
	*
	* Group players by shift similarity
	*
	*/

	var playerSets = [];
	var ungroupedPlayers = playerData.filter(function(d) { return d.team === team; })
		.map(function(d) { return d.playerId; });

	// Sort pairings by descending similarity, then start grouping players with the highest shift similarities
	var minSimilarity = 0.5;
	pairingData = pairingData.sort(function(a, b) { return b.shiftSimilarity - a.shiftSimilarity; });
	pairingData.forEach(function(pair) {
		if (pair.shiftSimilarity >= minSimilarity) {

			var grouped = false;

			// If 1 or more player sets exist, then check to see if the current pair should be added to an existing set
			var i = 0;
			while (!grouped && i < playerSets.length) {
				if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) < 0) {
					// If an existing set contains p1 but not p2, add p2 to the existing set
					playerSets[i].push(pair.p2);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) < 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set contains p2 but not p1, add p1 to the existing set
					playerSets[i].push(pair.p1);
					grouped = true;
				} else if (playerSets[i].indexOf(pair.p1) >= 0 && playerSets[i].indexOf(pair.p2) >= 0) {
					// If an existing set already contains both p1 and p2, then no updates needed
					grouped = true;
				}
				i++;
			}

			// If the existing pair doesn't belong to any existing player set, then create a new set
			if (!grouped) {
				playerSets.push([pair.p1, pair.p2]);
			}

			// Remove the grouped players from the list of ungrouped players
			[pair.p1, pair.p2].forEach(function(p) {
				var deleteIndex = ungroupedPlayers.indexOf(p);
				if (deleteIndex >= 0) {
					ungroupedPlayers.splice(deleteIndex, 1);
				}
			});
		}
	});

	// For testing: Print player sets with names
	// playerSets.forEach(function(set) {
	// 	var names = [];
	// 	set.forEach(function(p) {
	// 		playerName = playerData.filter(function(d) { return d.team === team && d.playerId === p; })[0].name;
	// 		names.push(playerName);
	// 	});
	// 	console.log(names);
	// });

	/*
	*
	* Sort all the sets and ungrouped players by descending TOI
	*
	*/

	var sortedPlayers = [];

	// Add the player sets to the list to be sorted
	// Sets will be sorted based on their average TOI
	playerSets.forEach(function(set) {

		// Get the shift data for each player in the set
		// Sort the players by descending TOI
		var setPlayers = shiftData.filter(function(p) { return set.indexOf(p.playerId) >= 0; });
		setPlayers.sort(function(a, b) { return b.toi - a.toi; });

		sortedPlayers.push({
			players: set,
			toi: d3.mean(setPlayers, function(p) { return p.toi; })
		});
	});

	// Add the ungrouped players to the list to be sorted
	ungroupedPlayers.forEach(function(player) {
		var playerData = shiftData.filter(function(p) { return p.playerId === player; });
		sortedPlayers.push({
			players: [player],
			toi: playerData[0].toi
		});
	});

	// Sort the combined list of sets and ungrouped players by descending TOI
	sortedPlayers.sort(function(a, b) { return b.toi - a.toi; });

	// Convert the sorted players into a flat list
	sortedPlayers = sortedPlayers.map(function(d) { return d.players; });
	sortedPlayers = [].concat.apply([], sortedPlayers);

	// Record the sort order in the shiftData
	shiftData.filter(function(p) { return p.team === team; })
		.forEach(function(p) {
			p.order = sortedPlayers.indexOf(p.playerId);
		});
}

</script>
</body>
</html>


